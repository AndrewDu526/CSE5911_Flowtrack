package com.example.testappflp;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import android.Manifest;
import android.content.pm.PackageManager;
import android.location.Location;
import android.location.LocationManager;
import android.os.Bundle;
import android.text.method.ScrollingMovementMethod;
import android.util.Log;
import android.widget.Button;
import android.widget.TextView;

import com.google.android.gms.location.Priority;
import com.google.android.gms.location.FusedLocationProviderClient;
import com.google.android.gms.location.LocationCallback;
import com.google.android.gms.location.LocationRequest;
import com.google.android.gms.location.LocationResult;
import com.google.android.gms.location.LocationServices;
import com.google.android.gms.tasks.CancellationTokenSource;
import com.google.gson.Gson;

import java.io.File;
import java.io.FileOutputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.UUID;

import models.TrackBatch;
import models.TrackPoint;

// TODO: organize file, break methods into several classes

public class MainActivity extends AppCompatActivity {


    private static final int BATCH_SIZE = 100;                 // size of batch, packaging when filled up
    private final List<TrackPoint> buffer = new ArrayList<>(); // memory cache
    private final Gson gson = new Gson();                      // packaging
    private static final String TAG = "FLP";
    private static final int REQ_LOC = 2001;
    private TextView txt;
    private FusedLocationProviderClient fused;
    private LocationCallback callback;

    // variables for HTTP posting
    private static final String BASE_URL = "http://100.110.147.24:18081"; // local url, depends on your local server address
    private static final String POST_PATH = "/FlowTrackServerReceiver"; // port path
    private final okhttp3.OkHttpClient http = new okhttp3.OkHttpClient();


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main); // R: resource index class auto generated by Android
        txt = findViewById(R.id.txt); // create log  window
        txt.setMovementMethod(new ScrollingMovementMethod()); // add scrolling function

        // bond view elements to Buttons
        Button btnOnce  = findViewById(R.id.btnOnce);
        Button btnStart = findViewById(R.id.btnStart);
        Button btnStop  = findViewById(R.id.btnStop);

        // google play fused location client
        fused = LocationServices.getFusedLocationProviderClient(this);

        // Java Lamba, set click listener to button
        btnOnce.setOnClickListener(v -> getOneTimeLocation());
        btnStart.setOnClickListener(v -> startUpdates());
        btnStop.setOnClickListener(v -> stopUpdates());
    }

    // TODO: replaced by Launcher, used in BLT demo
    private void getOneTimeLocation() {
        // check whether has permission, if not, request
        if (!hasLocationPermission()) {requestLocationPermission(); return;} // Asynchronous
        if (!isLocationEnabled()) { log("Please go to the settings to turn Location Service on."); return;}

        oneTimePositioningWithPermission();
    }

    private void startUpdates() {

        if (!hasLocationPermission()) {requestLocationPermission(); return;} // Asynchronous
        if (!isLocationEnabled()) { log("Please go to the settings to turn Location Service on."); return;}

        startUpdatesWithPermission();
    }

    // stop updates, needn't permission
    private void stopUpdates() {
        if (callback != null) {fused.removeLocationUpdates(callback);}
        log("Stop updating.");
    }

    @android.annotation.SuppressLint("MissingPermission") // remove static warning of "missing permission"
    private void oneTimePositioningWithPermission() {

        // create token
        CancellationTokenSource cts = new CancellationTokenSource();
        // getCurrentLocation only execute once, return Task<Location>
        try{
            fused.getCurrentLocation(Priority.PRIORITY_HIGH_ACCURACY, cts.getToken()).addOnSuccessListener(loc -> {
                if (loc != null) log("Get current location: \n" + locationFormatter(loc));
                else log("No available location");
            }).addOnFailureListener(e -> log("Exception occur fail to get location: " + e));
        } catch (SecurityException se) {
            log("Security exception occur：" + se.getMessage());
        }
    }

    @android.annotation.SuppressLint("MissingPermission")
    private void startUpdatesWithPermission() {
        // build request
        LocationRequest req = new LocationRequest.Builder(
                Priority.PRIORITY_HIGH_ACCURACY,
                5000L) // expected execute interval, may diff from real interval, will send multi locations in a list
                .setMinUpdateIntervalMillis(2000L) // min update interval 2 seconds, prevent updating too fast with meaningless info
                .build();

        if (callback == null) { // ensure only use one and same callback; TODO: design one-time-click start button
            callback = new LocationCallback() {
                @Override public void onLocationResult(@NonNull LocationResult result) { // @Nonnull, the annotated variable will not be Null
                    Location lastLoc = result.getLastLocation(); // get the last location from a location list;
                    // if (lastLoc != null) log("Update: " + locationFormatter(lastLoc));

                    // store all locations
                    for(Location loc:result.getLocations()){
                        if(loc!=null){locationAddToBuffer(loc);}
                    }
                }
            };
        }

        try {
            log("Start updating continuously…");
            fused.requestLocationUpdates(req, callback, getMainLooper()); // getMainLooper: execute callback's callback method in Main thread
        } catch (SecurityException se) {
            log("Security exception occur：" + se.getMessage());
        }
    }

    private void locationAddToBuffer(Location loc){

        // TODO: better clean/process strategy
        if (loc.hasAccuracy() && loc.getAccuracy() > 50f) {
            return;
        }

        TrackPoint point = new TrackPoint();

        point.tWall      = System.currentTimeMillis();
        point.tElapsedNs = android.os.SystemClock.elapsedRealtimeNanos();
        point.lat        = loc.getLatitude();
        point.lon        = loc.getLongitude();
        point.acc        = loc.getAccuracy();
        point.provider   = loc.getProvider();
        point.source     = "flp";
        point.priority   = "fine"; // TODO: priority
        point.floor      = null; // TODO: floor

        buffer.add(point);

        // TODO: better packaging conditional check, not only check size
        if (buffer.size() >= BATCH_SIZE) {
            packageTrackPointsFromBuffer();
        }
    }

    // TODO: better packaging strategy, based on time and size
    // current temp strategy: package all locations once it touches batch size
    private void packageTrackPointsFromBuffer(){
        // copy locations
        List<TrackPoint> locations = new ArrayList<>(buffer);
        // clean buffer
        buffer.clear();

        // TODO: Get and Set methods
        TrackBatch batch = new TrackBatch();
        batch.locations = locations;
        batch.batchId = UUID.randomUUID().toString(); // TODO
        batch.device = null; // TODO
        batch.employee = null; // TODO

        String json = gson.toJson(batch); // package to json
        log("Packed " + locations.size() + " points, json bytes ≈ " + json.length());

        saveJsonToFile(json); // temp file saving for check
        createAndStartPostingThread(json); // TODO: divide functions in diff methods(method names)
    }

    private void saveJsonToFile(String json) {
        try {
            File dir = new File(getExternalFilesDir(null), "FLP_output");
            if (!dir.exists()) dir.mkdirs();
            String fname = "batch_" + System.currentTimeMillis() + ".json";
            File f = new File(dir, fname);
            try (FileOutputStream fos = new FileOutputStream(f)) {
                fos.write(json.getBytes(StandardCharsets.UTF_8));
            }
            log("Saved to: " + f.getAbsolutePath());
        } catch (Exception e) {
            log("Save file error: " + e.getMessage());
        }
    }

    // HTTP posting json, return respond body
    private String postingTrackBatchToServer(String url, String json) throws Exception{
        okhttp3.MediaType JSON = okhttp3.MediaType.get("application/json; charset=utf-8");
        okhttp3.RequestBody body = okhttp3.RequestBody.create(json, JSON);
        okhttp3.Request request = new okhttp3.Request.Builder() // Syn posting, thread blocks until receive response or exception
                .url(url)
                .post(body)
                .build();

        try(okhttp3.Response respond = http.newCall(request).execute();){
            if(!respond.isSuccessful()){throw new RuntimeException("TrackBatch Posting Exception: HTTP " + respond.code());}
            return respond.body() != null ? respond.body().string() : "";
        }
    }

    private void createAndStartPostingThread(String json){
        new Thread(new Runnable() {
            @Override
            public void run() {
                String url = BASE_URL + POST_PATH;
                try{
                    String respond = postingTrackBatchToServer(url, json);
                    log("POST success to " + url + "\nRespond: " + respond);
                }catch(Exception e){
                    log("POST fail to " + url + "\nException: " + e);
                }
            }
        }).start();
    }

    private boolean hasLocationPermission() { // check whether activity context has fine location or coarse location permission
        return ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)// checkSelfPermission: Determine whether you have been granted a particular permission
                == PackageManager.PERMISSION_GRANTED // PERMISSION_GRANTED = 0; PERMISSION_DENIED = -1
                || ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION)
                == PackageManager.PERMISSION_GRANTED;
    }

    private void requestLocationPermission() {
        ActivityCompat.requestPermissions(
                this,
                new String[]{ Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION },// array to store requested permissions
                REQ_LOC // specific code to identify in diff permission requests(location, camera, memory...), assigned by coder
        );
    }

    private boolean isLocationEnabled() {
        LocationManager lm = (LocationManager) getSystemService(LOCATION_SERVICE);
        if (lm == null) return false;
        int mode = android.provider.Settings.Secure.getInt(
                getContentResolver(),
                android.provider.Settings.Secure.LOCATION_MODE,
                android.provider.Settings.Secure.LOCATION_MODE_OFF
        );
        return mode != android.provider.Settings.Secure.LOCATION_MODE_OFF;
    }

    private void requestLocationEnable(){
        // TODO: complete requestLocationEnable method, instead of print message
    }

    private String locationFormatter(Location location) {
        return String.format(Locale.US,
                "lat=%.6f, lon=%.6f, acc=%.1fm, provider=%s, time=%tT",
                location.getLatitude(), location.getLongitude(), location.getAccuracy(), location.getProvider(), location.getTime());
    }

    private void log(String s) { txt.append(s + "\n"); Log.d(TAG, s); } // TODO: replace this method by data packaging and sending

    @Override public void onRequestPermissionsResult(int code, @NonNull String[] p, @NonNull int[] r) {
        super.onRequestPermissionsResult(code, p, r);

        // check permission of location
        if (code == REQ_LOC) {
            boolean granted = false;
            for (int v : r) granted |= (v == PackageManager.PERMISSION_GRANTED);
            log(granted ? "Permission for location has been granted." : "No location permission granted");
        }
    }
}